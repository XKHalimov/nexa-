generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  email                String               @unique
  password             String
  createdAt            DateTime             @default(now())
  updatedAt            DateTime             @updatedAt
  isDeleted            Boolean              @default(false)
  firstName            String?
  lastName             String?
  username             String?
  id                   String               @id @default(uuid()) @db.Uuid
  role                 String               @default("user")
  levelId              String?              @default(uuid()) @db.Uuid
  referredBy           Referral[]           @relation("UserReferred")
  referralsMade        Referral[]           @relation("UserReferrals")
  transactions         Transaction[]
  userBadges           UserBadge[]
  wallet               Wallet?
  members              ConversationMember[]
  conversationsCreated Conversation[]       @relation("UserCreatedConversations")
  messages             Message[]
  premiumSubscription  PremiumSubscription?
  isPremium     Boolean         @default(false)
  profile              Profile?
  userBooster          UserBooster[]
  level                Level?               @relation(fields: [levelId], references: [id])
  xp Int @default(0)
  xpLogs               XpLog[]
  aiAccessLevel AiAccessLevel?  @relation(fields: [aiAccessLevelId], references: [id])
  aiAccessLevelId String?

  @@map("users")
}

model Profile {
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?
  isDeleted Boolean   @default(false)
  firstName String?
  lastName  String?
  id        String    @id @default(uuid()) @db.Uuid
  userId    String    @unique @db.Uuid
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("profiles")
}

model Conversation {
  title         String?
  isGroup       Boolean              @default(false)
  createdAt     DateTime             @default(now())
  updatedAt     DateTime             @updatedAt
  lastMessageAt DateTime?
  avatar        String?
  bio           String?
  id            String               @id @default(uuid()) @db.Uuid
  createdById   String?              @db.Uuid
  lastMessageId String?              @db.Uuid
  isDeleted     Boolean              @default(false)
  members       ConversationMember[]
  createdBy     User?                @relation("UserCreatedConversations", fields: [createdById], references: [id])
  messages      Message[]

  @@map("conversations")
}

model ConversationMember {
  joinedAt       DateTime     @default(now())
  id             String       @id @default(uuid()) @db.Uuid
  conversationId String       @db.Uuid
  userId         String       @db.Uuid
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([conversationId, userId])
  @@map("conversation_members")
}

model Message {
  content        String
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  isDeleted      Boolean       @default(false)
  id             String        @id @default(uuid()) @db.Uuid
  conversationId String        @db.Uuid
  senderId       String        @db.Uuid
  conversation   Conversation  @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender         User          @relation(fields: [senderId], references: [id], onDelete: Cascade)
  translations   Translation[]

  @@map("messages")
}

model Translation {
  sourceLang     String
  targetLang     String
  translatedText String?
  status         String              @default("pending")
  provider       String?
  error          String?
  createdAt      DateTime            @default(now())
  updatedAt      DateTime            @updatedAt
  id             String              @id @default(uuid()) @db.Uuid
  messageId      String              @db.Uuid
  outboxes       TranslationOutbox[]
  message        Message             @relation(fields: [messageId], references: [id], onDelete: Cascade)

  @@map("translations")
}

model TranslationOutbox {
  payload       Json
  status        OutboxStatus @default(queued)
  attempts      Int          @default(0)
  error         String?
  createdAt     DateTime     @default(now())
  processedAt   DateTime?
  id            String       @id @default(uuid()) @db.Uuid
  translationId String       @db.Uuid
  translation   Translation  @relation(fields: [translationId], references: [id], onDelete: Cascade)

  @@map("translation_outbox")
}

model AuditLog {
  id         BigInt   @id @default(autoincrement())
  table_name String
  operation  String
  row_id     String?  @db.Uuid
  actor_id   String?  @db.Uuid
  changed_at DateTime @default(now())
  before     Json?
  after      Json?

  @@map("audit_logs")
}

model XpLog {
  id        String   @id @default(uuid()) @db.Uuid
  userId    String   @db.Uuid
  action    String
  xpAmount  Int
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id])

  @@map("xp_logs")
}

model Booster {
  id         String        @id @default(uuid()) @db.Uuid
  name       String
  multiplier Float
  duration   Int
  users      UserBooster[]

  @@map("booster")
}

model UserBooster {
  id        String   @id @default(uuid()) @db.Uuid
  userId    String   @db.Uuid
  boosterId String   @db.Uuid
  expiresAt DateTime
  active    Boolean  @default(false)
  booster   Booster  @relation(fields: [boosterId], references: [id])
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_booster")
}

model PremiumSubscription {
  id        String   @id @default(uuid()) @db.Uuid
  userId    String   @unique @db.Uuid
  startDate DateTime @default(now())
  endDate   DateTime
  isActive  Boolean  @default(true)
  planType  String
  user      User     @relation(fields: [userId], references: [id])

  @@map("premium_subscriptions")
}

model Wallet {
  id        String   @id @default(uuid())
  userId    String   @unique @db.Uuid
  balance   Float    @default(0)
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id])
}

model Transaction {
  id        String          @id @default(uuid())
  userId    String          @db.Uuid
  type      TransactionType
  amount    Float
  itemType  String?
  itemId    String?
  createdAt DateTime        @default(now())
  user      User            @relation(fields: [userId], references: [id])
}

model Level {
  id    String @id @default(uuid()) @db.Uuid
  name  String
  xpMin Int
  xpMax Int
  users User[]
}

model Badge {
  id         String      @id @default(uuid()) @db.Uuid
  name       String
  condition  String
  userBadges UserBadge[]
}

model UserBadge {
  id        String   @id @default(uuid()) @db.Uuid
  userId    String   @db.Uuid
  badgeId   String   @db.Uuid
  createdAt DateTime @default(now())
  badge     Badge    @relation(fields: [badgeId], references: [id])
  user      User     @relation(fields: [userId], references: [id])
}

model Referral {
  id         String   @id @default(uuid())
  referrerId String   @db.Uuid
  referredId String   @db.Uuid
  createdAt  DateTime @default(now())
  referred   User     @relation("UserReferred", fields: [referredId], references: [id])
  referrer   User     @relation("UserReferrals", fields: [referrerId], references: [id])
}

enum OutboxStatus {
  queued
  processing
  processed
  failed
}

enum TransactionType {
  ADD_BALANCE
  PURCHASE
}
model AiAccessLevel {
  id        String   @id @default(uuid())
  name      String
  chatLimit Int
  speed     Int      // 1 = sekin, 2 = normal, 3 = tez
  xpFrom    Int?     // minimal XP (agar XP darajasiga bogâ€˜lasangiz)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user      User[]
}
